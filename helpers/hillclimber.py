#!/usr/bin/env python
# Gwydion Oostvogel, Sophie Schubert
"""
Hillclimber algorithm for smart grid.
"""

from copy import deepcopy
from random import shuffle


def hillclimber(grid, n):
    """
    With an initial solution (ie. generated by greedy algorithm) swap two connections and keep swap if the total length
    of cables is less than it was before the swap.
    :param grid: object
    :param n: int
    :return: object
    """
    # Get cable, house and battery dicts
    cables = grid.get_cables()
    batteries = grid.get_batteries()
    houses = grid.get_houses()
    # Get keys from the cable dictionary
    us_ckeys = list(cables.keys())
    ckeys = []

    # Sort houses by battery
    for bkey in batteries:
        group = []
        for ckey in us_ckeys:
            if cables[ckey].get_batt() == bkey:
                group.append(ckey)
        ckeys.append(group)

    for i in range(n):
        score = grid.tot_len()
        shuffle(ckeys)
        shuffle(ckeys[0])
        shuffle(ckeys[1])

        # Get two cables
        orgA = cables[ckeys[0][0]]
        orgB = cables[ckeys[1][0]]
        newA = deepcopy(orgA)
        newB = deepcopy(orgB)

        houseA = houses[orgA.get_id()]
        houseB = houses[orgB.get_id()]

        battA = batteries[orgA.get_batt()]
        battB = batteries[orgB.get_batt()]

        # Swap
        newA.change_route(houseA.get_coord(), battB.get_coord())
        newA.add_batt(battB.get_id())
        newB.change_route(houseB.get_coord(), battA.get_coord())
        newB.add_batt(battA.get_id())

        new_score = score - (orgA.get_length() + orgB.get_length()) + (newA.get_length() + newB.get_length())

        # If new configuration has a better score keep swap
        if score > new_score and battA.get_cap() + houseA.get_max() > houseB.get_max() and battB.get_cap() + houseB.get_max() > houseA.get_max():
            grid.rem_cable(orgA.get_id())
            grid.rem_cable(orgB.get_id())
            grid.add_cable(newA)
            grid.add_cable(newB)

        print('iteration:', i, 'best:', score, 'current:', new_score)

    return grid
